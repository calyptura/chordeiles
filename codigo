import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
import folium
from streamlit_folium import st_folium
import requests
from io import StringIO
import datetime
import calendar
import io
import matplotlib.pyplot as plt
import seaborn as sns
import time

# Aumentando o timeout para requisi√ß√µes
import socket

socket.setdefaulttimeout(30)  # Timeout de 30 segundos

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="Chordeiles: An√°lise de sazonalidade de esp√©cies",
    page_icon="ü¶Ö",
    layout="wide"
)


# Fun√ß√£o para converter string de data para datetime
def converter_data(data_str):
    try:
        return pd.to_datetime(data_str, format='%d/%m/%Y', errors='coerce')
    except:
        try:
            return pd.to_datetime(data_str, errors='coerce')
        except:
            return None


# Fun√ß√£o para download de arquivo CSV do Google Sheets
@st.cache_data(ttl=3600)
def download_csv_from_google_sheet(sheet_url):
    """
    Faz download direto da planilha como CSV, sem necessidade de API ou credenciais.
    Funciona apenas se a planilha estiver configurada para "Qualquer pessoa com o link pode visualizar".
    """
    try:
        # Extrai o ID da planilha
        sheet_id = sheet_url.split('/d/')[1].split('/edit')[0]

        # Constr√≥i a URL de exporta√ß√£o como CSV
        export_url = f"https://docs.google.com/spreadsheets/d/{sheet_id}/export?format=csv"

        # Faz a requisi√ß√£o HTTP
        response = requests.get(export_url)

        # Verifica se a requisi√ß√£o foi bem-sucedida
        if response.status_code == 200:
            # L√™ o conte√∫do como CSV
            csv_content = StringIO(response.content.decode('utf-8'))
            df = pd.read_csv(csv_content, low_memory=False)
            return df
        else:
            st.error(f"Erro ao baixar a planilha: {response.status_code}")
            st.warning("Verifique se a planilha est√° configurada para 'Qualquer pessoa com o link pode visualizar'.")
            return pd.DataFrame()

    except Exception as e:
        st.error(f"Erro ao fazer download da planilha: {e}")
        return pd.DataFrame()


# Fun√ß√£o para carregar e processar dados
def load_and_process_data(file_upload=None, sheet_url=None):
    """Carrega e processa os dados de um arquivo upload ou Google Sheets"""

    df = pd.DataFrame()

    # Carregando dados do upload de arquivo
    if file_upload is not None:
        try:
            # Obter o tipo de arquivo
            file_extension = file_upload.name.split('.')[-1].lower()

            if file_extension == 'csv':
                df = pd.read_csv(file_upload, low_memory=False)
            elif file_extension in ['xls', 'xlsx']:
                df = pd.read_excel(file_upload)
            else:
                st.error("Formato de arquivo n√£o suportado. Por favor, envie um arquivo CSV ou Excel.")
                return pd.DataFrame()
        except Exception as e:
            st.error(f"Erro ao carregar o arquivo: {e}")
            return pd.DataFrame()

    # Carregando dados do Google Sheets
    elif sheet_url is not None and sheet_url.strip() != "":
        df = download_csv_from_google_sheet(sheet_url)

    # Verifica√ß√£o de dados
    if df.empty:
        return pd.DataFrame()

    # Processamento dos dados
    # Padronizando nomes de colunas
    colunas_padronizadas = {
        'id registro': 'id_registro',
        'Esp√©cie': 'especie',
        'municipio e estado': 'municipio_estado',
        'Data (d/m/a)': 'data',
        'Autor': 'autor',
        'Munic√≠pio': 'municipio',
        'uf': 'estado',
        'id munic√≠pio': 'id_municipio',
        'latitude': 'latitude',
        'longitude': 'longitude'
    }

    # Renomear colunas se existirem no DataFrame
    for col_original, col_padronizada in colunas_padronizadas.items():
        if col_original in df.columns:
            df.rename(columns={col_original: col_padronizada}, inplace=True)

    # Processando a data
    if 'data' in df.columns:
        df['data'] = df['data'].apply(converter_data)
        df['ano'] = df['data'].dt.year
        df['mes'] = df['data'].dt.month
        df['mes_nome'] = df['data'].dt.month_name()

    return df


# Fun√ß√£o para calcular indicadores
def calcular_indicadores(df):
    """Calcula os indicadores principais com base nos dados filtrados"""
    # N√∫mero de registros
    n_registros = len(df)

    # N√∫mero de esp√©cies √∫nicas
    n_especies = df['especie'].nunique() if 'especie' in df.columns else 0

    # Localiza√ß√µes √∫nicas (combinando munic√≠pio e estado)
    if 'municipio' in df.columns and 'estado' in df.columns:
        n_localizacoes = df.drop_duplicates(subset=['municipio', 'estado']).shape[0]
    else:
        n_localizacoes = 0

    # Per√≠odo dos dados
    if 'data' in df.columns:
        data_inicio = df['data'].min().strftime('%d/%m/%Y') if not pd.isna(df['data'].min()) else "N/A"
        data_fim = df['data'].max().strftime('%d/%m/%Y') if not pd.isna(df['data'].max()) else "N/A"
        periodo_dados = f"{data_inicio} a {data_fim}"
    else:
        periodo_dados = "N/A"

    return {
        'n_registros': n_registros,
        'n_especies': n_especies,
        'n_localizacoes': n_localizacoes,
        'periodo_dados': periodo_dados
    }


# Fun√ß√£o para gerar tabela de registros por esp√©cie
def gerar_tabela_registros_por_especie(df):
    """Gera tabela com contagem de registros por esp√©cie"""
    if 'especie' not in df.columns:
        return pd.DataFrame()

    registros_por_especie = df['especie'].value_counts().reset_index()
    registros_por_especie.columns = ['Esp√©cie', 'N√∫mero de Registros']
    return registros_por_especie


# Fun√ß√£o para gerar gr√°fico de registros por esp√©cie
def gerar_grafico_registros_por_especie(df, tipo_grafico):
    """Gera gr√°fico de registros por esp√©cie conforme tipo selecionado"""
    if 'especie' not in df.columns:
        return None

    # Obter contagem de registros por esp√©cie
    registros_por_especie = df['especie'].value_counts().reset_index()
    registros_por_especie.columns = ['Esp√©cie', 'N√∫mero de Registros']

    # Limitar para as 15 esp√©cies mais registradas
    top_especies = registros_por_especie.head(15)

    if tipo_grafico == 'barras_horizontais':
        fig = px.bar(
            top_especies,
            y='Esp√©cie',
            x='N√∫mero de Registros',
            title='Esp√©cies mais Registradas',
            orientation='h',
            color='N√∫mero de Registros',
            color_continuous_scale='Viridis'
        )
    elif tipo_grafico == 'barras_verticais':
        fig = px.bar(
            top_especies,
            x='Esp√©cie',
            y='N√∫mero de Registros',
            title='Esp√©cies mais Registradas',
            color='N√∫mero de Registros',
            color_continuous_scale='Viridis'
        )
        fig.update_layout(xaxis_tickangle=-45)
    elif tipo_grafico == 'pizza':
        fig = px.pie(
            top_especies,
            values='N√∫mero de Registros',
            names='Esp√©cie',
            title='Distribui√ß√£o de Registros por Esp√©cie'
        )

    fig.update_layout(
        xaxis_title='Esp√©cie',
        yaxis_title='N√∫mero de Registros',
        autosize=True
    )

    return fig


# Fun√ß√£o para gerar mapa de registros
def gerar_mapa_registros(df, tipo_mapa, agrupar_pontos=True, grid_size=30,
                         valores_personalizados=False, limiar_azul=5, limiar_azul_medio=10,
                         limiar_amarelo=20, limiar_laranja=50):
    """Gera mapa de registros conforme tipo selecionado

    Args:
        df: DataFrame com os dados
        tipo_mapa: Tipo de mapa (pontos, calor, grid)
        agrupar_pontos: Se True, agrupa pontos pr√≥ximos em clusters
        grid_size: Tamanho do grid para tipo 'grid'
        valores_personalizados: Se True, usa limiares personalizados para cores
        limiar_azul: Valor m√°ximo para azul claro
        limiar_azul_medio: Valor m√°ximo para azul m√©dio
        limiar_amarelo: Valor m√°ximo para amarelo
        limiar_laranja: Valor m√°ximo para laranja
    """
    if 'latitude' not in df.columns or 'longitude' not in df.columns:
        return None

    # Filtrando coordenadas v√°lidas (sem chamar uma fun√ß√£o separada)
    df_mapa = df.copy()

    # Convertendo para float para garantir
    df_mapa['latitude'] = pd.to_numeric(df_mapa['latitude'], errors='coerce')
    df_mapa['longitude'] = pd.to_numeric(df_mapa['longitude'], errors='coerce')

    # Filtrar coordenadas v√°lidas (dentro dos limites do planeta)
    # Latitude: -90 a 90, Longitude: -180 a 180
    validos = (
            (df_mapa['latitude'] >= -90) & (df_mapa['latitude'] <= 90) &
            (df_mapa['longitude'] >= -180) & (df_mapa['longitude'] <= 180)
    )

    # Contando registros inv√°lidos
    n_invalidos = (~validos).sum()
    if n_invalidos > 0:
        st.warning(f"‚ö†Ô∏è {n_invalidos} registros com coordenadas inv√°lidas foram removidos.")

    df_mapa = df_mapa[validos].reset_index(drop=True)

    # Removendo registros sem coordenadas
    df_mapa = df_mapa.dropna(subset=['latitude', 'longitude'])

    if len(df_mapa) == 0:
        st.error("N√£o existem coordenadas v√°lidas nos dados selecionados.")
        return None

    # Limitar n√∫mero de pontos para melhorar o desempenho
    max_pontos = 2000  # Limite de pontos para evitar sobrecarga
    if len(df_mapa) > max_pontos and tipo_mapa != 'grid':
        st.warning(
            f"Limitando o mapa a {max_pontos} pontos para melhor desempenho. Use filtros para visualizar dados espec√≠ficos.")
        df_mapa = df_mapa.sample(max_pontos, random_state=42)

    try:
        # Solu√ß√£o simples, evitando usar muitos par√¢metros
        # Usando apenas os par√¢metros b√°sicos necess√°rios
        mapa = folium.Map(
            location=[-15.77972, -47.92972],  # Centro do Brasil (Bras√≠lia)
            zoom_start=4,
            tiles='OpenStreetMap'
        )

        # Adicionar camadas b√°sicas
        folium.TileLayer('OpenStreetMap', name='OpenStreetMap').add_to(mapa)

        if tipo_mapa == 'pontos':
            if agrupar_pontos:
                # Usar MarkerCluster para agrupar pontos
                from folium.plugins import MarkerCluster
                marker_cluster = MarkerCluster().add_to(mapa)

                # Adicionando pontos para cada registro
                for idx, row in df_mapa.iterrows():
                    try:
                        popup_text = f"""
                        <strong>Esp√©cie:</strong> {row.get('especie', 'N/A')}<br>
                        <strong>Local:</strong> {row.get('municipio', 'N/A')}/{row.get('estado', 'N/A')}<br>
                        """

                        folium.Marker(
                            location=[float(row['latitude']), float(row['longitude'])],
                            popup=folium.Popup(popup_text, max_width=300)
                        ).add_to(marker_cluster)
                    except Exception as e:
                        continue
            else:
                # Adicionar pontos individualmente sem agrupar
                for idx, row in df_mapa.iterrows():
                    try:
                        popup_text = f"""
                        <strong>Esp√©cie:</strong> {row.get('especie', 'N/A')}<br>
                        <strong>Local:</strong> {row.get('municipio', 'N/A')}/{row.get('estado', 'N/A')}<br>
                        """

                        folium.Marker(
                            location=[float(row['latitude']), float(row['longitude'])],
                            popup=folium.Popup(popup_text, max_width=300),
                            icon=folium.Icon(color='green')
                        ).add_to(mapa)
                    except Exception as e:
                        continue

        elif tipo_mapa == 'calor':
            try:
                # Preparando dados para mapa de calor, garantindo que sejam floats
                heat_data = [[float(row['latitude']), float(row['longitude'])] for idx, row in df_mapa.iterrows()]

                # Adicionando mapa de calor com configura√ß√£o simplificada
                from folium.plugins import HeatMap
                HeatMap(heat_data).add_to(mapa)
            except Exception as e:
                st.error(f"Erro no mapa de calor: {e}")

        elif tipo_mapa == 'grid':
            try:
                # Criar grid para visualiza√ß√£o
                # Definindo limites do grid
                min_lat = df_mapa['latitude'].min()
                max_lat = df_mapa['latitude'].max()
                min_lon = df_mapa['longitude'].min()
                max_lon = df_mapa['longitude'].max()

                # Verificando se a √°rea geogr√°fica √© v√°lida
                if min_lat > max_lat or min_lon > max_lon:
                    st.error("√Årea geogr√°fica inv√°lida - verifique as coordenadas.")
                    return mapa

                # Usando o tamanho do grid passado como par√¢metro

                # Calculando o tamanho das c√©lulas
                lat_step = (max_lat - min_lat) / grid_size
                lon_step = (max_lon - min_lon) / grid_size

                # Verificando se os passos s√£o v√°lidos
                if lat_step <= 0 or lon_step <= 0:
                    st.warning("√Årea geogr√°fica muito pequena para criar grid. Tente incluir mais dados.")
                    return mapa

                # Contadores para estat√≠sticas do grid
                celulas_total = grid_size * grid_size
                celulas_com_dados = 0
                max_registros = 0

                # Criando c√©lulas do grid
                grid_cells = {}

                # Atribuindo pontos √†s c√©lulas do grid
                for idx, row in df_mapa.iterrows():
                    try:
                        lat = float(row['latitude'])
                        lon = float(row['longitude'])

                        # Pular coordenadas que est√£o fora dos limites (caso tenha havido filtragem inadequada)
                        if lat < min_lat or lat > max_lat or lon < min_lon or lon > max_lon:
                            continue

                        # Determinando a c√©lula do grid para este ponto
                        lat_idx = int((lat - min_lat) / lat_step)
                        lon_idx = int((lon - min_lon) / lon_step)

                        # Ajustando para evitar √≠ndices fora dos limites
                        lat_idx = min(grid_size - 1, max(0, lat_idx))
                        lon_idx = min(grid_size - 1, max(0, lon_idx))

                        # Chave da c√©lula
                        cell_key = (lat_idx, lon_idx)

                        # Incrementando contagem na c√©lula
                        if cell_key in grid_cells:
                            grid_cells[cell_key]['count'] += 1
                            grid_cells[cell_key]['species'].add(row.get('especie', 'N/A'))
                        else:
                            celulas_com_dados += 1
                            grid_cells[cell_key] = {
                                'count': 1,
                                'lat': min_lat + (lat_idx + 0.5) * lat_step,
                                'lon': min_lon + (lon_idx + 0.5) * lon_step,
                                'species': {row.get('especie', 'N/A')}
                            }
                    except Exception as e:
                        continue

                # Encontrando o valor m√°ximo para normaliza√ß√£o de cores
                if grid_cells:
                    max_count = max([cell['count'] for cell in grid_cells.values()])
                    max_registros = max_count
                else:
                    max_count = 1
                    max_registros = 0

                # Exibir informa√ß√µes sobre o grid para debug
                st.write(f"Grid de {grid_size}x{grid_size} c√©lulas ({celulas_total} c√©lulas no total)")
                st.write(f"√Årea geogr√°fica: Lat [{min_lat:.2f} a {max_lat:.2f}], Lon [{min_lon:.2f} a {max_lon:.2f}]")
                st.write(f"Tamanho da c√©lula: {lat_step:.4f}¬∞ latitude x {lon_step:.4f}¬∞ longitude")
                st.write(
                    f"C√©lulas com registros: {celulas_com_dados} de {celulas_total} ({celulas_com_dados / celulas_total * 100:.1f}%)")
                st.write(f"M√°ximo de registros em uma c√©lula: {max_registros}")

                # Criando uma classe para a legenda do mapa
                class MacroElement(folium.MacroElement):
                    def __init__(self, html_string):
                        super(MacroElement, self).__init__()
                        self._template = folium.elements.Template(html_string)

                # Definir as cores e limiares para a legenda
                if valores_personalizados:
                    # Usar os limiares fornecidos pelo usu√°rio
                    valor_azul = limiar_azul
                    valor_azul_medio = limiar_azul_medio
                    valor_amarelo = limiar_amarelo
                    valor_laranja = limiar_laranja
                    valor_vermelho = f">{limiar_laranja}"
                else:
                    # Calculando limiares autom√°ticos baseados na distribui√ß√£o
                    counts = [cell_data['count'] for cell_data in grid_cells.values()]
                    if len(counts) == 0:
                        # Se n√£o h√° dados, usar valores padr√£o
                        valor_azul = "1-5"
                        valor_azul_medio = "6-10"
                        valor_amarelo = "11-20"
                        valor_laranja = "21-50"
                        valor_vermelho = ">50"
                    else:
                        # Dividir em 5 categorias baseadas na distribui√ß√£o
                        max_count = max(counts)
                        if max_count < 5:
                            # Poucos registros, usar valores absolutos
                            valor_azul = "1"
                            valor_azul_medio = "2"
                            valor_amarelo = "3"
                            valor_laranja = "4"
                            valor_vermelho = "‚â•5"
                        else:
                            # Usar valores relativos √† distribui√ß√£o
                            valor_azul = f"1-{max(1, int(max_count * 0.2))}"
                            valor_azul_medio = f"{int(max_count * 0.2) + 1}-{int(max_count * 0.4)}"
                            valor_amarelo = f"{int(max_count * 0.4) + 1}-{int(max_count * 0.6)}"
                            valor_laranja = f"{int(max_count * 0.6) + 1}-{int(max_count * 0.8)}"
                            valor_vermelho = f"{int(max_count * 0.8) + 1}-{max_count}"

                # Criando a legenda HTML
                legend_html = f'''
                <div id="maplegend" style="position: fixed; z-index:9999; border:2px solid grey; background-color:rgba(255, 255, 255, 0.8);
                    border-radius:6px; padding: 10px; font-size:14px; right: 20px; bottom: 20px;">
                    <div style="font-weight: bold; margin-bottom: 10px;">N√∫mero de Registros</div>
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <div style="background: #ADD8E6; width: 20px; height: 20px; margin-right: 8px; border: 1px solid #333;"></div>
                        <span>{valor_azul}</span>
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <div style="background: #6495ED; width: 20px; height: 20px; margin-right: 8px; border: 1px solid #333;"></div>
                        <span>{valor_azul_medio}</span>
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <div style="background: #FFFF00; width: 20px; height: 20px; margin-right: 8px; border: 1px solid #333;"></div>
                        <span>{valor_amarelo}</span>
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <div style="background: #FFA500; width: 20px; height: 20px; margin-right: 8px; border: 1px solid #333;"></div>
                        <span>{valor_laranja}</span>
                    </div>
                    <div style="display: flex; align-items: center;">
                        <div style="background: #FF0000; width: 20px; height: 20px; margin-right: 8px; border: 1px solid #333;"></div>
                        <span>{valor_vermelho}</span>
                    </div>
                </div>
                <style>
                @media(max-width: 992px) {{
                    #maplegend {{
                        display: block;
                        max-width: 150px;
                    }}
                }}
                </style>
                '''

                # Adicionando a legenda ao mapa usando a MacroElement
                mapa.get_root().add_child(MacroElement(legend_html))

                # Criando ret√¢ngulos para cada c√©lula do grid que cont√©m dados
                for cell_key, cell_data in grid_cells.items():
                    # Calculando coordenadas do ret√¢ngulo
                    lat_idx, lon_idx = cell_key

                    south = min_lat + lat_idx * lat_step
                    north = min_lat + (lat_idx + 1) * lat_step
                    west = min_lon + lon_idx * lon_step
                    east = min_lon + (lon_idx + 1) * lon_step

                    # Definindo cores baseadas nos limiares personalizados ou na contagem normalizada
                    count = cell_data['count']

                    if valores_personalizados:
                        # Usando valores absolutos definidos pelo usu√°rio
                        if count <= limiar_azul:
                            color = '#ADD8E6'  # Azul claro
                            opacity = 0.6
                        elif count <= limiar_azul_medio:
                            color = '#6495ED'  # Azul m√©dio
                            opacity = 0.65
                        elif count <= limiar_amarelo:
                            color = '#FFFF00'  # Amarelo
                            opacity = 0.7
                        elif count <= limiar_laranja:
                            color = '#FFA500'  # Laranja
                            opacity = 0.75
                        else:
                            color = '#FF0000'  # Vermelho
                            opacity = 0.8
                    else:
                        # Usando valores relativos (normalizados)
                        # Normalizando a contagem para definir a cor (0-1)
                        norm_count = count / max_count

                        if norm_count < 0.2:
                            color = '#ADD8E6'  # Azul claro
                            opacity = 0.6
                        elif norm_count < 0.4:
                            color = '#6495ED'  # Azul m√©dio
                            opacity = 0.65
                        elif norm_count < 0.6:
                            color = '#FFFF00'  # Amarelo
                            opacity = 0.7
                        elif norm_count < 0.8:
                            color = '#FFA500'  # Laranja
                            opacity = 0.75
                        else:
                            color = '#FF0000'  # Vermelho
                            opacity = 0.8

                    # Texto do popup
                    popup_text = f"""
                    <strong>Registros:</strong> {cell_data['count']}<br>
                    <strong>Esp√©cies:</strong> {len(cell_data['species'])}<br>
                    <strong>Coordenadas:</strong> {south:.4f},{west:.4f} a {north:.4f},{east:.4f}
                    """

                    # Criando ret√¢ngulo para a c√©lula com borda mais vis√≠vel
                    folium.Rectangle(
                        bounds=[[south, west], [north, east]],
                        color='black',
                        weight=1,
                        fill=True,
                        fill_color=color,
                        fill_opacity=opacity,
                        popup=folium.Popup(popup_text, max_width=300)
                    ).add_to(mapa)

            except Exception as e:
                st.error(f"Erro ao gerar mapa de grid: {e}")

        return mapa

    except Exception as e:
        st.error(f"Erro ao gerar mapa: {e}")
        # Retornar um mapa b√°sico como fallback
        return folium.Map(location=[-15.77972, -47.92972], zoom_start=4)


# Fun√ß√£o para gerar gr√°fico de registros por localidade
def gerar_grafico_registros_por_localidade(df, tipo_grafico):
    """Gera gr√°fico de registros por localidade conforme tipo selecionado"""
    if 'municipio' not in df.columns or 'estado' not in df.columns:
        return None

    # Criando coluna de localidade (munic√≠pio/estado)
    df['localidade'] = df['municipio'] + '/' + df['estado']

    # Contando registros por localidade
    registros_por_localidade = df['localidade'].value_counts().reset_index()
    registros_por_localidade.columns = ['Localidade', 'N√∫mero de Registros']

    # Obtendo as 20 principais localidades
    top_localidades = registros_por_localidade.head(20)

    if tipo_grafico == 'barras_horizontais':
        fig = px.bar(
            top_localidades,
            y='Localidade',
            x='N√∫mero de Registros',
            title='Localidades com Mais Registros',
            orientation='h',
            color='N√∫mero de Registros',
            color_continuous_scale='Viridis'
        )
    elif tipo_grafico == 'barras_verticais':
        fig = px.bar(
            top_localidades,
            x='Localidade',
            y='N√∫mero de Registros',
            title='Localidades com Mais Registros',
            color='N√∫mero de Registros',
            color_continuous_scale='Viridis'
        )
        fig.update_layout(xaxis_tickangle=-45)
    elif tipo_grafico == 'pizza':
        fig = px.pie(
            top_localidades,
            values='N√∫mero de Registros',
            names='Localidade',
            title='Distribui√ß√£o de Registros por Localidade'
        )

    fig.update_layout(
        xaxis_title='Localidade',
        yaxis_title='N√∫mero de Registros',
        autosize=True
    )

    return fig


# Fun√ß√£o para gerar gr√°ficos personalizados
def gerar_grafico_personalizado(df, tipo_grafico):
    """Gera gr√°ficos personalizados baseados na sele√ß√£o do usu√°rio"""
    if df.empty:
        return None

    if tipo_grafico == 'linha':
        # Gr√°fico de linha para an√°lise temporal
        if 'data' not in df.columns:
            return None

        # Agrupando por m√™s e ano
        df_temporal = df.copy()
        df_temporal['ano_mes'] = df_temporal['data'].dt.to_period('M')

        # Contando registros por m√™s
        contagem_temporal = df_temporal.groupby('ano_mes').size().reset_index()
        contagem_temporal.columns = ['Ano-M√™s', 'N√∫mero de Registros']
        contagem_temporal['Ano-M√™s'] = contagem_temporal['Ano-M√™s'].astype(str)

        fig = px.line(
            contagem_temporal,
            x='Ano-M√™s',
            y='N√∫mero de Registros',
            title='Evolu√ß√£o Temporal dos Registros',
            markers=True
        )

    elif tipo_grafico == 'linha_sazonalidade':
        # Gr√°fico de linha para sazonalidade
        if 'especie' not in df.columns or 'mes' not in df.columns:
            return None

        # Agrupamento por esp√©cie e m√™s
        especies_por_mes = df.groupby(['especie', 'mes']).size().reset_index(name='registros')

        # Pegar as 5 esp√©cies mais frequentes para n√£o sobrecarregar o gr√°fico
        top_especies = df['especie'].value_counts().nlargest(5).index.tolist()
        especies_por_mes_filtrado = especies_por_mes[especies_por_mes['especie'].isin(top_especies)]

        # Ordenar por m√™s
        especies_por_mes_filtrado = especies_por_mes_filtrado.sort_values('mes')

        # Adicionar nomes dos meses
        especies_por_mes_filtrado['mes_nome'] = especies_por_mes_filtrado['mes'].apply(lambda x: calendar.month_abbr[x])

        # Criar gr√°fico
        fig = px.line(
            especies_por_mes_filtrado,
            x='mes_nome',
            y='registros',
            color='especie',
            title='Sazonalidade das Esp√©cies Mais Frequentes',
            markers=True
        )

        # Ordenar eixo X por m√™s
        fig.update_layout(
            xaxis={'categoryorder': 'array',
                   'categoryarray': [calendar.month_abbr[i] for i in range(1, 13)]},
            xaxis_title='M√™s',
            yaxis_title='N√∫mero de Registros'
        )

    elif tipo_grafico == 'barras_verticais':
        # Gr√°fico de barras verticais para an√°lise sazonal (m√™s)
        if 'mes' not in df.columns:
            return None

        # Contando registros por m√™s
        contagem_meses = df.groupby('mes').size().reset_index()
        contagem_meses.columns = ['M√™s', 'N√∫mero de Registros']

        # Ordenando os meses
        contagem_meses = contagem_meses.sort_values('M√™s')

        # Adicionando nomes dos meses
        nomes_meses = [calendar.month_name[m] for m in contagem_meses['M√™s']]
        contagem_meses['Nome do M√™s'] = nomes_meses

        fig = px.bar(
            contagem_meses,
            x='Nome do M√™s',
            y='N√∫mero de Registros',
            title='Sazonalidade dos Registros (Mensal)',
            color='N√∫mero de Registros',
            color_continuous_scale='Viridis'
        )

        # Definindo ordem espec√≠fica para os meses
        fig.update_layout(
            xaxis={'categoryorder': 'array',
                   'categoryarray': [calendar.month_name[i] for i in range(1, 13)]}
        )

    elif tipo_grafico == 'roseta':
        # Gr√°fico de roseta (circular) para an√°lise sazonal
        if 'mes' not in df.columns:
            return None

        # Contando registros por m√™s
        contagem_meses = df.groupby('mes').size().reset_index()
        contagem_meses.columns = ['M√™s', 'N√∫mero de Registros']

        # Ordenando os meses
        contagem_meses = contagem_meses.sort_values('M√™s')

        # Criando roseta
        fig = go.Figure()

        fig.add_trace(go.Barpolar(
            r=contagem_meses['N√∫mero de Registros'],
            theta=[calendar.month_abbr[m] for m in contagem_meses['M√™s']],
            width=1,
            marker_color=contagem_meses['N√∫mero de Registros'],
            marker_colorscale='Viridis',
            marker_showscale=True
        ))

        fig.update_layout(
            title='Sazonalidade dos Registros (Roseta)',
            polar=dict(
                radialaxis=dict(
                    visible=True,
                    showticklabels=True
                )
            )
        )

    return fig


# Fun√ß√£o para gerar gr√°fico de sazonalidade para uma esp√©cie espec√≠fica
def gerar_grafico_sazonalidade_especie(df, especie):
    """Gera gr√°fico de sazonalidade (registros por m√™s) para uma esp√©cie espec√≠fica"""
    if 'especie' not in df.columns or 'mes' not in df.columns:
        return None

    # Filtrando pela esp√©cie selecionada
    df_especie = df[df['especie'] == especie]

    if len(df_especie) == 0:
        return None

    # Contando registros por m√™s
    contagem_meses = df_especie.groupby('mes').size().reindex(range(1, 13), fill_value=0)
    contagem_meses = contagem_meses.reset_index()
    contagem_meses.columns = ['M√™s', 'N√∫mero de Registros']

    # Adicionando nomes dos meses
    contagem_meses['Nome do M√™s'] = [calendar.month_name[m] for m in contagem_meses['M√™s']]

    # Criando gr√°fico
    fig = px.bar(
        contagem_meses,
        x='Nome do M√™s',
        y='N√∫mero de Registros',
        title=f'Sazonalidade: {especie}',
        color='N√∫mero de Registros',
        color_continuous_scale='Viridis'
    )

    # Definindo ordem espec√≠fica para os meses
    fig.update_layout(
        xaxis={'categoryorder': 'array',
               'categoryarray': [calendar.month_name[i] for i in range(1, 13)]},
        xaxis_title='M√™s',
        yaxis_title='N√∫mero de Registros'
    )

    return fig


# UI do Dashboard - Layout principal
def main():
    st.title("Chordeiles: An√°lise de sazonalidade de esp√©cies")

    # Sidebar - Op√ß√µes e Filtros
    st.sidebar.title("Upload de Dados")

    # Op√ß√£o para upload de arquivo ou Google Sheets
    fonte_dados = st.sidebar.radio(
        "Fonte de dados:",
        options=["Upload de arquivo", "Google Sheets"]
    )

    # Inicializando o DataFrame de dados
    df = pd.DataFrame()

    if fonte_dados == "Upload de arquivo":
        file_upload = st.sidebar.file_uploader(
            "Fazer upload de arquivo CSV ou Excel:",
            type=["csv", "xlsx", "xls"],
            help="Selecione um arquivo CSV ou Excel contendo os dados para an√°lise."
        )

        if file_upload is not None:
            df = load_and_process_data(file_upload=file_upload)
    else:
        sheet_url = st.sidebar.text_input(
            "Link do Google Sheets:",
            help="Cole o link compartilh√°vel do Google Sheets (permiss√£o de visualiza√ß√£o p√∫blica)."
        )

        if st.sidebar.button("Carregar Dados"):
            if sheet_url and sheet_url.strip() != "":
                df = load_and_process_data(sheet_url=sheet_url)

    # Verificando se temos dados para trabalhar
    if df.empty:
        # Se n√£o tiver dados, tentar carregar o arquivo de exemplo
        try:
            st.info("Tentando carregar arquivo de exemplo 'pachyramphus_chordeiles.csv'...")

            # Verifica se o arquivo existe antes de tentar carregar
            import os
            if os.path.exists('pachyramphus_chordeiles.csv'):
                df = pd.read_csv('pachyramphus_chordeiles.csv', low_memory=False)
            else:
                st.warning("Arquivo de exemplo n√£o encontrado. Por favor, fa√ßa upload de um arquivo.")
                # Criar um DataFrame vazio mas com as colunas necess√°rias
                df = pd.DataFrame(columns=['id_registro', 'especie', 'municipio_estado', 'data',
                                           'autor', 'municipio', 'estado', 'id_municipio',
                                           'latitude', 'longitude'])
                return

            # Processando o arquivo de exemplo
            if not df.empty:
                # Padronizando colunas
                df.rename(columns={
                    'id registro': 'id_registro',
                    'Esp√©cie': 'especie',
                    'municipio e estado': 'municipio_estado',
                    'Data (d/m/a)': 'data',
                    'Autor': 'autor',
                    'Munic√≠pio': 'municipio',
                    'uf': 'estado',
                    'id munic√≠pio': 'id_municipio',
                    'latitude': 'latitude',
                    'longitude': 'longitude'
                }, inplace=True)

                # Processando a data
                if 'data' in df.columns:
                    df['data'] = df['data'].apply(converter_data)
                    df['ano'] = df['data'].dt.year
                    df['mes'] = df['data'].dt.month
                    df['mes_nome'] = df['data'].dt.month_name()

                st.success("Arquivo de exemplo carregado com sucesso!")
            else:
                st.warning(
                    "Nenhum dado carregado. Por favor, fa√ßa upload de um arquivo ou forne√ßa um link do Google Sheets.")
                return
        except Exception as e:
            st.warning(
                f"Nenhum dado carregado. Por favor, fa√ßa upload de um arquivo ou forne√ßa um link do Google Sheets. Erro: {e}")
            # Criar um DataFrame vazio mas com as colunas necess√°rias
            df = pd.DataFrame(columns=['id_registro', 'especie', 'municipio_estado', 'data',
                                       'autor', 'municipio', 'estado', 'id_municipio',
                                       'latitude', 'longitude'])
            return

    # Sidebar - Filtros
    st.sidebar.title("Filtros")

    # Filtrando esp√©cies dispon√≠veis
    especies_disponiveis = sorted(df['especie'].unique()) if 'especie' in df.columns else []

    # Filtro de esp√©cie - Multi-select
    especie_selecionada = st.sidebar.multiselect(
        "Filtro Esp√©cie",
        options=especies_disponiveis,
        default=[]
    )

    # Dicion√°rio de regi√µes e seus estados
    regioes_brasil = {
        "Todas": [],
        "Norte": ["AC", "AP", "AM", "PA", "RO", "RR", "TO"],
        "Nordeste": ["MA", "PI", "CE", "RN", "PB", "PE", "AL", "SE", "BA"],
        "Centro-Oeste": ["DF", "GO", "MT", "MS"],
        "Sudeste": ["ES", "MG", "RJ", "SP"],
        "Sul": ["PR", "SC", "RS"]
    }

    # Filtrando estados dispon√≠veis
    estados_disponiveis = sorted(df['estado'].unique()) if 'estado' in df.columns else []

    # Sele√ß√£o de regi√£o
    regiao_selecionada = st.sidebar.selectbox(
        "Filtrar por Regi√£o",
        options=list(regioes_brasil.keys())
    )

    # Filtro de estado - Multi-select
    # Pr√©-selecionar estados da regi√£o escolhida
    estados_pre_selecionados = []
    if regiao_selecionada != "Todas":
        estados_pre_selecionados = [estado for estado in estados_disponiveis if
                                    estado in regioes_brasil[regiao_selecionada]]

    estado_selecionado = st.sidebar.multiselect(
        "Filtro Estado",
        options=estados_disponiveis,
        default=estados_pre_selecionados
    )

    # Filtrando munic√≠pios dispon√≠veis
    municipios_disponiveis = sorted(df['municipio'].unique()) if 'municipio' in df.columns else []

    # Filtro de munic√≠pio - Multi-select
    municipio_selecionado = st.sidebar.multiselect(
        "Filtro Munic√≠pio",
        options=municipios_disponiveis,
        default=[]
    )

    # Dicion√°rio de esta√ß√µes e seus meses
    estacoes_ano = {
        "Todas": [],
        "Ver√£o": [12, 1, 2],  # Dezembro, Janeiro, Fevereiro
        "Outono": [3, 4, 5],  # Mar√ßo, Abril, Maio
        "Inverno": [6, 7, 8],  # Junho, Julho, Agosto
        "Primavera": [9, 10, 11]  # Setembro, Outubro, Novembro
    }

    # Sele√ß√£o de esta√ß√£o
    estacao_selecionada = st.sidebar.selectbox(
        "Filtrar por Esta√ß√£o",
        options=list(estacoes_ano.keys())
    )

    # Filtro de m√™s - Multi-select
    # Pr√©-selecionar meses da esta√ß√£o escolhida
    meses_disponiveis = [i for i in range(1, 13)]
    meses_nomes = [calendar.month_name[i] for i in meses_disponiveis]

    meses_pre_selecionados = []
    if estacao_selecionada != "Todas":
        meses_pre_selecionados = [calendar.month_name[i] for i in estacoes_ano[estacao_selecionada]]

    mes_selecionado = st.sidebar.multiselect(
        "Filtro M√™s",
        options=meses_nomes,
        default=meses_pre_selecionados
    )

    # Filtrando anos dispon√≠veis
    anos_disponiveis = sorted(df['ano'].unique()) if 'ano' in df.columns else []

    # Filtro de ano - Multi-select
    ano_selecionado = st.sidebar.multiselect(
        "Filtro Ano",
        options=[str(ano) for ano in anos_disponiveis],
        default=[]
    )

    # Aplicando filtros
    df_filtrado = df.copy()

    # Filtrar por esp√©cie
    if especie_selecionada and 'especie' in df_filtrado.columns:
        df_filtrado = df_filtrado[df_filtrado['especie'].isin(especie_selecionada)]

    # Filtrar por munic√≠pio
    if municipio_selecionado and 'municipio' in df_filtrado.columns:
        df_filtrado = df_filtrado[df_filtrado['municipio'].isin(municipio_selecionado)]

    # Filtrar por estado
    if estado_selecionado and 'estado' in df_filtrado.columns:
        df_filtrado = df_filtrado[df_filtrado['estado'].isin(estado_selecionado)]

    # Filtrar por ano
    if ano_selecionado and 'ano' in df_filtrado.columns:
        df_filtrado = df_filtrado[df_filtrado['ano'].isin([int(ano) for ano in ano_selecionado])]

    # Filtrar por m√™s
    if mes_selecionado and 'mes_nome' in df_filtrado.columns:
        df_filtrado = df_filtrado[df_filtrado['mes_nome'].isin(mes_selecionado)]

    # Calculando indicadores
    indicadores = calcular_indicadores(df_filtrado)

    # Painel Geral - Per√≠odo e Indicadores
    st.markdown("## Painel geral")

    # Cards para indicadores com componentes nativos do Streamlit
    col1, col2, col3 = st.columns(3)

    with col1:
        st.metric(label="TOTAL DE REGISTROS", value=indicadores['n_registros'])

    with col2:
        st.metric(label="TOTAL DE ESP√âCIES", value=indicadores['n_especies'])

    with col3:
        st.metric(label="TOTAL DE LOCALIDADES √öNICAS", value=indicadores['n_localizacoes'])

    # Per√≠odo amostral
    st.info(f"**PER√çODO AMOSTRAL:** {indicadores['periodo_dados']}")

    st.markdown("---")

    # Registros por esp√©cie - Tabela e Gr√°fico
    col1, col2 = st.columns(2)

    with col1:
        st.markdown("### Registros por esp√©cie")

        tabela_especies = gerar_tabela_registros_por_especie(df_filtrado)
        if not tabela_especies.empty:
            st.dataframe(tabela_especies, height=400)
        else:
            st.warning("Dados insuficientes para gerar a tabela.")

    with col2:
        st.markdown("### Registros por esp√©cie")

        opcoes_grafico_especies = [
            "Barras horizontais",
            "Barras verticais",
            "Pizza"
        ]

        tipo_grafico_especies = st.selectbox(
            "Tipo de gr√°fico:",
            options=opcoes_grafico_especies,
            key="grafico_especies"
        )

        tipo_map = {
            "Barras horizontais": "barras_horizontais",
            "Barras verticais": "barras_verticais",
            "Pizza": "pizza"
        }

        fig_especies = gerar_grafico_registros_por_especie(df_filtrado, tipo_map[tipo_grafico_especies])
        if fig_especies:
            st.plotly_chart(fig_especies, use_container_width=True)
        else:
            st.warning("Dados insuficientes para gerar o gr√°fico.")

    st.markdown("---")

    # Mapa geral e Gr√°fico por localidade
    col1, col2 = st.columns(2)

    with col1:
        st.markdown("### Mapa geral de registro")

        opcoes_mapa = [
            "Mapa de pontos",
            "Mapa de calor",
            "Mapa de grid"
        ]

        tipo_mapa = st.selectbox(
            "Tipo de mapa:",
            options=opcoes_mapa
        )

        tipo_mapa_map = {
            "Mapa de pontos": "pontos",
            "Mapa de calor": "calor",
            "Mapa de grid": "grid"
        }

        # Op√ß√£o para agrupar pontos (mostrar apenas se for mapa de pontos)
        if tipo_mapa == "Mapa de pontos":
            agrupar_pontos = st.checkbox("Agrupar pontos pr√≥ximos", value=True,
                                         help="Quando marcado, agrupa pontos pr√≥ximos para melhor visualiza√ß√£o. Desmarque para ver pontos individuais.")
        else:
            agrupar_pontos = True

        # Se for mapa de grid, mostrar as informa√ß√µes em um container expand√≠vel
        if tipo_mapa == "Mapa de grid":
            with st.expander("Detalhes do grid", expanded=False):
                st.info(
                    "Criando visualiza√ß√£o de grid. Esta an√°lise divide a √°rea em c√©lulas e conta registros em cada uma.")
                grid_size = st.slider("Tamanho do grid (c√©lulas)", min_value=5, max_value=100, value=30,
                                      help="Define a resolu√ß√£o do grid. Valores maiores criam c√©lulas menores.")
        else:
            grid_size = 30

        # Aviso sobre problemas de mapa
        st.info("Se o mapa n√£o aparecer, tente reduzir a quantidade de dados usando os filtros")

        mapa = gerar_mapa_registros(df_filtrado, tipo_mapa_map[tipo_mapa], agrupar_pontos, grid_size)
        if mapa:
            try:
                # Usando uma altura maior para mapas de grid, que precisam de mais espa√ßo
                altura_mapa = 500 if tipo_mapa == "Mapa de grid" else 450
                st_folium(mapa, width='100%', height=altura_mapa, key="mapa_geral")
            except Exception as e:
                st.error(f"Erro ao exibir o mapa: {e}")
                st.info("Tente aplicar mais filtros para reduzir o volume de dados")
        else:
            st.warning("Dados insuficientes para gerar o mapa.")

        st.caption("Visualiza√ß√£o do mapa automaticamente ajustada para os dados")

    with col2:
        st.markdown("### Gr√°fico de registros por localidade")

        opcoes_grafico_localidade = [
            "Barras horizontais",
            "Barras verticais",
            "Pizza"
        ]

        tipo_grafico_localidade = st.selectbox(
            "Tipo de gr√°fico:",
            options=opcoes_grafico_localidade,
            key="grafico_localidade"
        )

        fig_localidade = gerar_grafico_registros_por_localidade(
            df_filtrado,
            tipo_map[tipo_grafico_localidade]
        )

        if fig_localidade:
            st.plotly_chart(fig_localidade, use_container_width=True)
        else:
            st.warning("Dados insuficientes para gerar o gr√°fico.")

    st.markdown("---")

    # Mapa personalizado
    st.markdown("### Op√ß√µes de personaliza√ß√£o do mapa")

    opcoes_mapa_personalizado = [
        "Mapa de pontos",
        "Mapa de calor",
        "Mapa de grid",
        "Mapa com filtro de esp√©cie"
    ]

    # Usando uma chave espec√≠fica para este selectbox para evitar conflitos
    tipo_mapa_personalizado = st.selectbox(
        "Tipo de mapa:",
        options=opcoes_mapa_personalizado,
        key="mapa_personalizado_tipo"
    )

    # Aplicar filtros adicionais conforme sele√ß√£o
    df_mapa_personalizado = df_filtrado.copy()

    if tipo_mapa_personalizado == "Mapa com filtro de esp√©cie":
        # Usando uma chave espec√≠fica para este selectbox tamb√©m
        if especies_disponiveis:
            especie_mapa = st.selectbox(
                "Esp√©cie para o mapa:",
                options=especies_disponiveis,
                key="especie_mapa_select"
            )

            df_mapa_personalizado = df_mapa_personalizado[df_mapa_personalizado['especie'] == especie_mapa]
        else:
            st.warning("N√£o h√° esp√©cies dispon√≠veis com os filtros atuais.")

    tipo_mapa_pers_map = {
        "Mapa de pontos": "pontos",
        "Mapa de calor": "calor",
        "Mapa de grid": "grid",
        "Mapa com filtro de esp√©cie": "pontos"
    }

    # Op√ß√£o para agrupar pontos (mostrar apenas se for mapa de pontos)
    if tipo_mapa_personalizado in ["Mapa de pontos", "Mapa com filtro de esp√©cie"]:
        agrupar_pontos_pers = st.checkbox("Agrupar pontos pr√≥ximos", value=True,
                                          help="Quando marcado, agrupa pontos pr√≥ximos para melhor visualiza√ß√£o. Desmarque para ver pontos individuais.",
                                          key="agrupar_pontos_pers")
    else:
        agrupar_pontos_pers = True

    # Op√ß√£o para tamanho do grid (mostrar apenas se for mapa de grid)
    if tipo_mapa_personalizado == "Mapa de grid":
        with st.expander("Detalhes do grid", expanded=False):
            st.info(
                "Criando visualiza√ß√£o de grid. Esta an√°lise divide a √°rea em c√©lulas e conta registros em cada uma.")

            col1, col2 = st.columns(2)

            with col1:
                grid_size_pers = st.slider("Tamanho do grid (c√©lulas)", min_value=5, max_value=100, value=30,
                                           help="Define a resolu√ß√£o do grid. Valores maiores criam c√©lulas menores.",
                                           key="grid_size_pers")

            with col2:
                usar_valores_personalizados = st.checkbox("Usar valores personalizados para cores",
                                                          value=False,
                                                          help="Define manualmente os limiares de cores",
                                                          key="usar_valores_personalizados")

            if usar_valores_personalizados:
                st.write("Define os limiares para cada cor do grid:")

                col1, col2 = st.columns(2)
                with col1:
                    limiar_azul = st.number_input("Azul claro (at√©)", value=5, min_value=1, step=1,
                                                  key="limiar_azul")
                    limiar_azul_medio = st.number_input("Azul m√©dio (at√©)", value=10, min_value=limiar_azul + 1, step=1,
                                                        key="limiar_azul_medio")

                with col2:
                    limiar_amarelo = st.number_input("Amarelo (at√©)", value=20, min_value=limiar_azul_medio + 1, step=1,
                                                     key="limiar_amarelo")
                    limiar_laranja = st.number_input("Laranja (at√©)", value=50, min_value=limiar_amarelo + 1, step=1,
                                                     key="limiar_laranja")

                st.write(f"Vermelho: mais de {limiar_laranja} registros")
            else:
                # Valores padr√£o se n√£o estiver usando personalizados
                limiar_azul = 5
                limiar_azul_medio = 10
                limiar_amarelo = 20
                limiar_laranja = 50
    else:
        grid_size_pers = 30
        usar_valores_personalizados = False
        limiar_azul = 5
        limiar_azul_medio = 10
        limiar_amarelo = 20
        limiar_laranja = 50

    # Aviso sobre problemas de mapa
    st.info("Se o mapa n√£o aparecer, tente reduzir a quantidade de dados usando os filtros")

    # Garantindo que temos uma chave v√°lida
    tipo_map_key = tipo_mapa_pers_map.get(tipo_mapa_personalizado, "pontos")

    mapa_personalizado = gerar_mapa_registros(df_mapa_personalizado, tipo_map_key, agrupar_pontos_pers,
                                              grid_size_pers if tipo_mapa_personalizado == "Mapa de grid" else 30,
                                              usar_valores_personalizados, limiar_azul, limiar_azul_medio,
                                              limiar_amarelo, limiar_laranja)
    if mapa_personalizado:
        try:
            # Usando uma altura maior para mapas de grid, que precisam de mais espa√ßo
            altura_mapa = 500 if tipo_mapa_personalizado == "Mapa de grid" else 450
            st_folium(mapa_personalizado, width='100%', height=altura_mapa, key="mapa_pers_visual")
        except Exception as e:
            st.error(f"Erro ao exibir o mapa personalizado: {e}")
            st.info("Tente aplicar mais filtros para reduzir o volume de dados")
    else:
        st.warning("Dados insuficientes para gerar o mapa personalizado.")

    st.caption("Visualiza√ß√£o do mapa automaticamente ajustada para os dados")

    st.markdown("---")

    # Gr√°fico personalizado
    st.markdown("### Op√ß√µes de personaliza√ß√£o do gr√°fico")

    opcoes_grafico_personalizado = [
        "Gr√°fico de linha (tend√™ncia temporal)",
        "Gr√°fico de linha (sazonalidade)",
        "Gr√°fico de barras verticais (sazonalidade)",
        "Gr√°fico de roseta (sazonalidade)"
    ]

    tipo_grafico_personalizado = st.selectbox(
        "Tipo de gr√°fico:",
        options=opcoes_grafico_personalizado
    )

    tipo_grafico_pers_map = {
        "Gr√°fico de linha (tend√™ncia temporal)": "linha",
        "Gr√°fico de linha (sazonalidade)": "linha_sazonalidade",
        "Gr√°fico de barras verticais (sazonalidade)": "barras_verticais",
        "Gr√°fico de roseta (sazonalidade)": "roseta"
    }

    fig_personalizado = gerar_grafico_personalizado(
        df_filtrado,
        tipo_grafico_pers_map[tipo_grafico_personalizado]
    )

    if fig_personalizado:
        st.plotly_chart(fig_personalizado, use_container_width=True)
    else:
        st.warning("Dados insuficientes para gerar o gr√°fico personalizado.")

    # Se for uma op√ß√£o de sazonalidade e houver esp√©cies dispon√≠veis, permitir sele√ß√£o de esp√©cie espec√≠fica
    if tipo_grafico_personalizado in ["Gr√°fico de barras verticais (sazonalidade)", "Gr√°fico de roseta (sazonalidade)"]:
        if especies_disponiveis:
            st.subheader("An√°lise de sazonalidade por esp√©cie")

            especie_sazonalidade = st.selectbox(
                "Selecione uma esp√©cie para analisar sazonalidade:",
                options=especies_disponiveis
            )

            fig_sazonalidade = gerar_grafico_sazonalidade_especie(df_filtrado, especie_sazonalidade)

            if fig_sazonalidade:
                st.plotly_chart(fig_sazonalidade, use_container_width=True)
            else:
                st.warning("Dados insuficientes para gerar o gr√°fico de sazonalidade.")

    # Rodap√©
    st.markdown("---")
    st.markdown(
        """
        <div style="text-align: center; font-size: 0.8rem;">
            Dashboard de An√°lise de Sazonalidade | Vers√£o 1.0 | Desenvolvido com Streamlit
        </div>
        """,
        unsafe_allow_html=True
    )


if __name__ == "__main__":
    main()
